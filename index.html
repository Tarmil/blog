<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Une pipe |&gt; Ceci n&#39;est pas</title>
    <meta id='websharper-data' name='websharper-data' content='{"$TYPES":[["WebSharper","Web","FSharpInlineControl"]],"$DATA":{"$V":{"ws152434960":{"$T":0,"$V":{"args":[],"funcName":["Blog","Client","Main"]}}}}}' />
<link type="text/css" rel="stylesheet" href="/css/all.css"></link>
<link type="text/css" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/styles/atom-one-light.min.css"></link>

  </head>
  <body>
    <header class="hero is-medium">
      <div class="hero-body">
        <div class="container">
          <a href="/">
            <h1 class="title">Une pipe |&gt; Ceci n&#39;est pas</h1>
            <h2 class="subtitle">Random functional thoughts</h2>
          </a>
        </div>
      </div>
    </header>
    <section class="section">
      <div class="container">
        <div class="columns">
          <div class="column is-two-thirds">
            <div class="content">
              <p>Welcome! I am Loïc Denuzière aka &quot;Tarmil&quot;, and this is my technical blog.
I'm a French developer who's quite passionate about functional programming, and I've been using F# for most of my work for over ten years.</p>
<p>I've been one of the main developers of <a href="https://websharper.com">WebSharper</a>, the F# web framework with both server-side and JavaScript-compiled client-side tools.
Recently I've been focusing more on <a href="https://fsbolero.io">Bolero</a>, a library that runs F# applications in WebAssembly using Blazor, and other personal projects.</p>
<p>Follow me on <a href="https://twitter.com/tarmil_">Twitter</a>, <a href="https://mastodon.social/@tarmil" rel="me">Mastodon</a> and find me on <a href="https://github.com/tarmil">GitHub</a>.</p>
<article class="section">
                  <h1><a href="article/2022/9/25/systemtextjson-v1.0">FSharp.SystemTextJson 1.0 released!</a></h1>
                  <p>More than three years after the first release, I am happy to announce <a href="https://github.com/tarmil/fsharp.systemtextjson">FSharp.SystemTextJson</a> version 1.0!</p>
<p>FSharp.SystemTextJson is a library that provides support for F# types in .NET's standard <a href="https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/how-to?pivots=dotnet-6-0">System.Text.Json</a>.</p>
<p>Here is a summary of the new features in v1.0.</p>
<h2 id="jsonname-attribute"><code>JsonName</code> attribute</h2>
<p>System.Text.Json provides an attribute <code>JsonPropertyName</code> to change the name of a property in JSON.
In FSharp.SystemTextJson 1.0, the new attribute <a href="https://github.com/Tarmil/FSharp.SystemTextJson/blob/master/docs/Customizing.md#jsonname"><code>JsonName</code></a> is equivalent but provides more functionality:</p>
<ul>
<li><p>When used on a discriminated union case, <code>JsonName</code> can take a value of type <code>int</code> or <code>bool</code> instead of <code>string</code>.</p>
<pre><code class="language-fsharp">type MyUnion =
    | [&lt;JsonName 1&gt;] One of x: int
    | [&lt;JsonName 2&gt;] Two of y: string

let options = JsonSerializerOptions()
options.Converters.Add(JsonFSharpConverter(JsonUnionEncoding.Default ||| JsonUnionEncoding.InternalTag ||| JsonUnionEncoding.NamedFields))
JsonSerializer.Serialize(Two &quot;two&quot;, options)
// =&gt; {&quot;Case&quot;:2,&quot;x&quot;:&quot;two&quot;}
</code></pre>
</li>
<li><p><code>JsonName</code> can take multiple values.
When deserializing, all these values are treated as equivalent.
When serializing, the first one is used.</p>
<pre><code class="language-fsharp">type Name =
    { [&lt;JsonName(&quot;firstName&quot;, &quot;first&quot;)&gt;]
      First: string
      [&lt;JsonName(&quot;lastName&quot;, &quot;last&quot;)&gt;]
      Last: string }

let options = JsonSerializerOptions()
options.Converters.Add(JsonFSharpConverter())
JsonSerializer.Deserialize&lt;Name&gt;(&quot;&quot;&quot;{&quot;first&quot;:&quot;John&quot;,&quot;last&quot;:&quot;Doe&quot;}&quot;&quot;&quot;, options)
// =&gt; { First = &quot;John&quot;; Last = &quot;Doe&quot; }

JsonSerializer.Serialize({ First = &quot;John&quot;; Last = &quot;Doe&quot; }, options)
// =&gt; {&quot;firstName&quot;:&quot;John&quot;,&quot;lastName&quot;:&quot;Doe&quot;}
</code></pre>
</li>
<li><p><code>JsonName</code> has a settable property <code>Field: string</code>.
It is used to set the JSON name of a union case field with the given name.</p>
<pre><code class="language-fsharp">type Contact =
    | [&lt;JsonName(&quot;email&quot;, Field = &quot;address&quot;)&gt;]
      Email of address: string
    | Phone of number: string

let options = JsonSerializerOptions()
options.Converters.Add(JsonFSharpConverter(JsonUnionEncoding.Default ||| JsonUnionEncoding.InternalTag ||| JsonUnionEncoding.NamedFields))
JsonSerializer.Serialize(Email &quot;john.doe@example.com&quot;)
// =&gt; {&quot;Case&quot;:&quot;Email&quot;,&quot;email&quot;:&quot;john.doe@example.com&quot;}
</code></pre>
</li>
</ul>
<h2 id="record-properties">Record properties</h2>
<p>By default, FSharp.SystemTextJson only serializes the fields of a record.
There are now two ways to also serialize their properties:</p>
<ul>
<li><p>The option <code>includeRecordProperties: bool</code> enables serializing all record properties (except those that have the attribute <code>JsonIgnore</code>, just like fields).</p>
<pre><code class="language-fsharp">type User =
    { id: int
      name: string }

    member this.profileUrl = $&quot;https://example.com/user/{this.id}/{this.name}&quot;

    [&lt;JsonIgnore&gt;]
    member this.notIncluded = &quot;This property is not included&quot;

let options = JsonSerializerOptions()
options.Converters.Add(JsonFSharpConverter(includeRecordProperties = true))
JsonSerializer.Serialize({ id = 1234; name = &quot;john.doe&quot; })
// =&gt; {&quot;id&quot;:1234,&quot;name&quot;:&quot;john.doe&quot;,&quot;profileUrl&quot;:&quot;https://example.com/user/1234/john.doe&quot;}
</code></pre>
</li>
<li><p>The attribute <code>JsonInclude</code> can be used on a specific property to serialize it.</p>
<pre><code class="language-fsharp">type User =
    { id: int
      name: string }

    [&lt;JsonInclude&gt;]
    member this.profileUrl = $&quot;https://example.com/user/{this.id}/{this.name}&quot;

    member this.notIncluded = &quot;This property is not included&quot;

let options = JsonSerializerOptions()
options.Converters.Add(JsonFSharpConverter())
JsonSerializer.Serialize({ id = 1234; name = &quot;john.doe&quot; })
// =&gt; {&quot;id&quot;:1234,&quot;name&quot;:&quot;john.doe&quot;,&quot;profileUrl&quot;:&quot;https://example.com/user/1234/john.doe&quot;}
</code></pre>
</li>
</ul>
<h2 id="breaking-change-missing-fields">BREAKING CHANGE: Missing fields</h2>
<p>In FSharp.SystemTextJson 0.x, using default options, missing fields of type <code>option</code> or <code>voption</code> would be deserialized into <code>None</code> or <code>ValueNone</code>.
This was unintended behavior, which is corrected in version 1.0: these missing fields now throw an error.
To restore the previous behavior, either enable the option <code>IgnoreNullValues = true</code>, or or use the type <a href="https://github.com/Tarmil/FSharp.SystemTextJson/blob/master/docs/Format.md#skippable"><code>Skippable</code></a> instead of <code>option</code> or <code>voption</code>.</p>
<p>Additionally, the option <code>DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull</code> is now treated as a synonym for <code>IgnoreNullValues = true</code>.</p>
<pre><code class="language-fsharp">type Name =
    { firstName: string
      lastName: string option }

let options = JsonSerializerOptions()
options.Converters.Add(JsonFSharpConverter())
JsonSerializer.Deserialize&lt;Name&gt;(&quot;&quot;&quot;{&quot;firstName&quot;:&quot;John&quot;}&quot;&quot;&quot;, options)
// =&gt; JsonException

let options2 = JsonSerializerOptions(IgnoreNullValues = true)
options2.Converters.Add(JsonFSharpConverter())
JsonSerializer.Deserialize&lt;Name&gt;(&quot;&quot;&quot;{&quot;firstName&quot;:&quot;John&quot;}&quot;&quot;&quot;, options2)
// =&gt; { firstName = &quot;John&quot;; lastName = None }

let options3 = JsonSerializerOptions(DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull)
options3.Converters.Add(JsonFSharpConverter())
JsonSerializer.Deserialize&lt;Name&gt;(&quot;&quot;&quot;{&quot;firstName&quot;:&quot;John&quot;}&quot;&quot;&quot;, options3)
// =&gt; { firstName = &quot;John&quot;; lastName = None }

type NameWithSkippable =
    { firstName: string
      lastName: Skippable&lt;string&gt; }

let options4 = JsonSerializerOptions()
options4.Converters.Add(JsonFSharpConverter())
JsonSerializer.Deserialize&lt;Name&gt;(&quot;&quot;&quot;{&quot;firstName&quot;:&quot;John&quot;}&quot;&quot;&quot;, options4)
// =&gt; { firstName = &quot;John&quot;; lastName = Skip }
</code></pre>
<h2 id="built-in-support-in.net-6-and-jsonfsharptypes">Built-in support in .NET 6 and JsonFSharpTypes</h2>
<p>In .NET 6, support has been added in System.Text.Json for a number of F# types.
This support is different from FSharp.SystemTextJson in a number of ways:</p>
<ul>
<li>Records, tuples, lists, sets, maps: <code>null</code> is accepted by the deserializer, and returns a null value.</li>
<li>Records: missing fields are deserialized to default value instead of throwing an error.</li>
<li>Maps: only primitive keys are supported. Numbers and booleans are converted to string and used as JSON objet keys.</li>
<li>Tuples: only supports up to 8 items, and serializes it as a JSON object with keys &quot;Item1&quot;, &quot;Item2&quot;, etc.</li>
<li>Discriminated unions, struct tuples: not supported.</li>
</ul>
<p>FSharp.SystemTextJson takes over the serialization of these types by default; but the option <a href="https://github.com/Tarmil/FSharp.SystemTextJson/blob/master/docs/Customizing.md#types"><code>types: JsonFSharpTypes</code></a> allows customizing which types should be serialized by <code>FSharp.SystemTextJson</code>, and which types should be left to <code>System.Text.Json</code>.</p>
<pre><code class="language-fsharp">let options = JsonSerializerOptions()
// Only use FSharp.SystemTextJson for records and unions:
options.Converters.Add(JsonFSharpOptions(types = (JsonFSharpTypes.Records ||| JsonFSharpTypes.Unions)))

JsonSerializer.Serialize(Map [(1, &quot;one&quot;); (2, &quot;two&quot;)], options)
// =&gt; {&quot;1&quot;:&quot;one&quot;,&quot;2&quot;:&quot;two&quot;}
// whereas FSharp.SystemTextJson would have serialized as:
// =&gt; [[1,&quot;one&quot;],[2,&quot;two&quot;]]
</code></pre>
<p>Happy coding!</p>
<p><small><em>By Lo&#239;c &quot;Tarmil&quot; Denuzi&#232;re on Sunday, September 25, 2022</em></small></p>
                  <p class="are-tags"><a href="tag/fsharp" class="tag">fsharp</a> <a href="tag/release" class="tag">release</a> <a href="tag/library" class="tag">library</a> <a href="tag/fsharp-systemtextjson" class="tag">fsharp-systemtextjson</a> <a class="tag is-info" href="https://twitter.com/intent/tweet?url=https://tarmil.fr/article/2022/9/25/systemtextjson-v1.0&amp;text=FSharp.SystemTextJson+1.0+released!&amp;hashtags=fsharp,release,library,fsharp-systemtextjson">Tweet</a> <a class="tag is-link" href="https://tarmil.fr/article/2022/9/25/systemtextjson-v1.0">Permalink</a> </p>
                </article><article class="section">
                  <h1><a href="article/2022/5/27/fsharp-data-literalproviders-1-0">FSharp.Data.LiteralProviders 1.0 is here!</a></h1>
                  <p>I am happy to announce that the library <a href="https://github.com/tarmil/fsharp.data.literalproviders">FSharp.Data.LiteralProviders</a> has reached version 1.0!</p>
<p>FSharp.Data.LiteralProviders is an F# type provider library that provides compile-time constants from various sources, such as environment variables or files:</p>
<pre><code class="language-fsharp">open FSharp.Data.LiteralProviders

// Get a value from an environment variable, another one from a file,
// and pass them to another type provider.

let [&lt;Literal&gt;] ConnectionString = Env&lt;&quot;CONNECTION_STRING&quot;&gt;.Value
let [&lt;Literal&gt;] GetUserDataQuery = TextFile&lt;&quot;GetUserData.sql&quot;&gt;.Text

type GetUserData = FSharp.Data.SqlCommandProvider&lt;GetUserDataQuery, ConnectionString&gt;

let getUserData (userId: System.Guid) =
    GetUserData.Create().Execute(UserId = userId)
</code></pre>
<p>Here is a summary of the new features in v1.0.</p>
<h2 id="running-an-external-command">Running an external command</h2>
<p>The <code>Exec</code> provider runs an external command during compilation and provides its output.</p>
<pre><code class="language-fsharp">open FSharp.Data.LiteralProviders

let [&lt;Literal&gt;] Branch = Exec&lt;&quot;git&quot;, &quot;branch --show-current&quot;&gt;.Output
</code></pre>
<p>More options are available to pass input, get the error output, the exit code, etc.
See <a href="https://github.com/Tarmil/FSharp.Data.LiteralProviders/blob/master/README.md#exec">the documentation</a>.</p>
<h2 id="conditionals">Conditionals</h2>
<p>The sub-namespaces <code>String</code>, <code>Int</code> and <code>Bool</code> provide a collection of compile-time conditional operators for the corresponding types.</p>
<p>For example, you can compare two integer values with <code>Int.LT</code>; combine two booleans with <code>Bool.OR</code>; or choose between two strings with <code>String.IF</code>.</p>
<pre><code class="language-fsharp">open FSharp.Data.LiteralProviders

// Compute the version: get the latest git tag, and add the branch if it's not master or main.

let [&lt;Literal&gt;] TagVersion = Exec&lt;&quot;git&quot;, &quot;describe --tags&quot;&gt;.Output

let [&lt;Literal&gt;] Branch = Exec&lt;&quot;git&quot;, &quot;branch --show-current&quot;&gt;.Output

// Note: the `const` keyword is an F# language quirk, necessary when nesting type providers.
let [&lt;Literal&gt;] IsMainBranch =
    Bool.OR&lt;
        const(String.EQ&lt;Branch, &quot;master&quot;&gt;.Value),
        const(String.EQ&lt;Branch, &quot;main&quot;&gt;.Value)
    &gt;.Value

let [&lt;Literal&gt;] Version =
    String.IF&lt;IsMainBranch,
        Then = TagVersion,
        Else = const(TagVersion + &quot;-&quot; + Branch)
    &gt;.Value
</code></pre>
<p>See <a href="https://github.com/Tarmil/FSharp.Data.LiteralProviders/blob/master/README.md#conditionals">the documentation</a> for all the operators available.</p>
<h2 id="value-as-int-and-as-bool">Value as int and as bool</h2>
<p>The providers try to parse string values as integer and as boolean. If any of these succeed, a value suffixed with <code>AsInt</code> or <code>AsBool</code> is provided.</p>
<pre><code class="language-fsharp">open FSharp.Data.LiteralProviders

let [&lt;Literal&gt;] runNumberAsString = Env&lt;&quot;GITHUB_RUN_NUMBER&quot;&gt;.Value // eg. &quot;42&quot;

let [&lt;Literal&gt;] runNumberAsInt = Env&lt;&quot;GITHUB_RUN_NUMBER&quot;&gt;.ValueAsInt // eg. 42
</code></pre>
<p><small><em>By Lo&#239;c &quot;Tarmil&quot; Denuzi&#232;re on Friday, May 27, 2022</em></small></p>
                  <p class="are-tags"><a href="tag/fsharp" class="tag">fsharp</a> <a href="tag/release" class="tag">release</a> <a href="tag/library" class="tag">library</a> <a href="tag/literalproviders" class="tag">literalproviders</a> <a class="tag is-info" href="https://twitter.com/intent/tweet?url=https://tarmil.fr/article/2022/5/27/fsharp-data-literalproviders-1-0&amp;text=FSharp.Data.LiteralProviders+1.0+is+here!&amp;hashtags=fsharp,release,library,literalproviders">Tweet</a> <a class="tag is-link" href="https://tarmil.fr/article/2022/5/27/fsharp-data-literalproviders-1-0">Permalink</a> </p>
                </article><article class="section">
                  <h1><a href="article/2019/12/17/elmish-page-model">Managing page-specific models in Elmish</a></h1>
                  <blockquote>
<p>This article is part of <a href="https://sergeytihon.com/2019/11/05/f-advent-calendar-in-english-2019/">F# Advent Calendar 2019</a>.</p>
</blockquote>
<p>GUI applications (web or otherwise) often display their content in one of a number of pages.
You can have a login page, a dashboard page, a details page for a type of item, and so on.
Whichever page is currently displayed generally has some state (or model, in Elmish parlance) that only makes sense for this page, and can be dropped when switching to a different page.
In this article we'll look into a few ways that such a page-specific model can be represented in an Elmish application.
The code uses Bolero, but the ideas can apply to any Elmish-based framework, like Fable-Elmish or Fabulous.</p>
<p>Our running example will be a simple book collection app with two pages: a list of books with a text input to filter the books by title, and a book details page.</p>
<pre><code class="language-fsharp">type Page =
    | List
    | Book of isbn: string

type Book =
    { isbn: string // We use the ISBN as unique identifier
      title: string
      publishDate: DateTime
      author: string }
</code></pre>
<p>Note that there can also be some state which, although only used by one page, should be stored in the main model anyway because it needs to persist between page switches.
For example, in our application, we don't want to reload the list of all book summaries whenever we switch back to the List page, so we will always store it in the main model.</p>
<h2 id="page-model-in-the-main-model">Page model in the main model</h2>
<p>One way to go is to just store each page's model as a field of the main application model.
However, we quickly encounter a problem: the state for all pages needs to be initialized from the beginning, not just the initial page.</p>
<pre><code class="language-fsharp">type ListPageModel =
    { filter: string }
    
type BookPageModel = Book

type Model =
    { page: Page
      books: Book list
      list: ListPageModel
      book: BookPageModel }

let initialModel =
    { page = List
      books = []
      list = { filter = &quot;&quot; }
      book = ??? // What should we put here?
    }
</code></pre>
<p>We can of course use an option:</p>
<pre><code class="language-fsharp">type Model =
    { // We don't need to store the page anymore,
      // since that is determined by which model is Some.
      // page: Page
      books: Book list
      list: ListPageModel option
      book: BookPageModel option }

let initialModel =
    { books = []
      list = Some { filter = &quot;&quot; }
      book = None }
</code></pre>
<p>But this violates a principle that I would rather keep true: <em>illegal states should be unrepresentable</em>.
What this means is that it is possible to put the application in a nonsensical state, where the <code>page</code> is <code>Book</code> but the <code>book</code> is <code>None</code>.
Our <code>update</code> and <code>view</code> functions will have to deal with this using partial functions (ie. functions that aren't correct for all possible input values, and throw exceptions otherwise) such as <code>Option.get</code>.</p>
<pre><code class="language-fsharp">type BookMsg =
    | SetAuthor of string
    // ...

type Msg =
    | Goto of Page
    | ListMsg of ListMsg
    | BookMsg of BookMsg
    // ...

let update msg model =
    match msg with
    | BookMsg bookMsg -&gt;
        let bookModel = Option.get model.book // !!!!
        let bookModel, cmd = updateBook bookMsg bookModel
        { model with book = Some bookModel }, Cmd.map BookMsg cmd
    // ...

let view model dispatch =
    match model.page with
    | Book isbn -&gt;
        let bookModel = Option.get model.book // !!!!
        bookView bookModel (dispatch &lt;&lt; BookMsg)
    // ...
</code></pre>
<p>Additionally, when switching pages, in addition to initializing the state of the new page, we may need to make sure that we set the model of other pages to <code>None</code>.
In this particular example, each model is very light, so it doesn't really matter; but if there are many different pages and some of their models are large in memory, this can become a concern.</p>
<pre><code class="language-fsharp">let update msg model =
    match msg with
    | Goto List -&gt;
        { model with
            list = Some { filter = &quot;&quot; }
            book = None // Don't forget this!
        }, Cmd.none
    | Goto (Book isbn) -&gt;
        match model.books |&gt; List.tryFind (fun book -&gt; book.isbn = isbn) with
        | Some book -&gt;
            { model with
                list = None // Don't forget this!
                book = Some book
            }, Cmd.none
        | None -&gt;
            model, Cmd.ofMsg (Error (&quot;Unknown book: &quot; + isbn))
    // ...
</code></pre>
<p>Despite these inconvenients, this style is a good choice for an application whose page are organized in a stack, where each page is only accessed directly from a parent page.
Actually, the fact that the model can contain several page states becomes an advantage when doing page transition animations, since during the animation, two pages are in fact displayed on the screen.
In particular, this is quite common for mobile applications.
Because of this, it is a recommended style in Fabulous, <a href="https://github.com/TimLariviere/FabulousContacts/blob/47a921ce28e06114b37f49d00ea5d5343fede89d/FabulousContacts/App.fs#L23-L25">as shown by the sample application FabulousContacts</a>.</p>
<h2 id="page-model-in-a-union">Page model in a union</h2>
<h3 id="separate-page-union-and-page-model-union">Separate page union and page model union</h3>
<p>An alternative is to store the page model as a union, with one case per page just like the <code>Page</code> union, but with models as arguments.</p>
<pre><code class="language-fsharp">type PageModel =
    | List of ListPageModel
    | Book of BookPageModel

type Model =
    { page: PageModel
      books: Book list }

let initialModel =
    { page = PageModel.List { filter = &quot;&quot; }
      books = [] }
</code></pre>
<p>The model is now correct by construction: it is not possible to accidentally construct an inconsistent state.</p>
<p>Unfortunately the types still allow receiving eg. a <code>BookMsg</code> when the current page is not <code>Book</code>; but such messages can just be ignored.
A nice way to do this is to match on the message and the page together:</p>
<pre><code class="language-fsharp">let update msg model =
    match msg, model.page with
    | ListMsg listMsg, List listModel -&gt;
        let listModel, cmd = updateList listMsg listModel
        { model with page = List listModel }, Cmd.map ListMsg cmd
    | ListMsg _, _ -&gt; model, Cmd.none // Ignore irrelevant message
    | BookMsg bookMsg, Book bookModel -&gt;
        let bookModel, cmd = updateBook bookMsg bookModel
        { model with page = Book bookModel }, Cmd.map BookMsg cmd
    | BookMsg _, _ -&gt; model, Cmd.none // Ignore irrelevant message
    // ...
</code></pre>
<p>Note: we could handle all irrelevant messages at once in a final <code>| _ -&gt; model, Cmd.none</code>, but then we would lose the exhaustiveness check on <code>msg</code>.
So if later we add a message but forget to handle it, the compiler wouldn't warn us.</p>
<p>As before, when switching to a page, the initial model is decided in the update handler for the <code>Goto</code> message.</p>
<pre><code class="language-fsharp">let update msg model =
    match msg with
    | Goto Page.List -&gt;
        let pageModel = PageModel.List { filter = &quot;&quot; }
        { model with page = pageModel }, Cmd.none
    | Goto (Page.Book isbn) -&gt;
        match model.books |&gt; List.tryFind (fun book -&gt; book.isbn = isbn) with
        | Some book -&gt;
            { model with page = PageModel.Book book }, Cmd.none
        | None -&gt;
            model, Cmd.ofMsg (Error (&quot;Unknown book: &quot; + isbn))
    // ...
</code></pre>
<h3 id="boleros-pagemodelt">Bolero's <code>PageModel&lt;'T&gt;</code></h3>
<p><a href="https://fsbolero.io/docs/Routing#page-models">Bolero contains a facility</a> to handle such a page model style.
It is essentially the same as the previous style, with some internal magic to avoid the need for a separate union type while still playing nice with Bolero's automatic URL routing system.</p>
<h2 id="separate-elmish-program">Separate Elmish program</h2>
<p>Finally, I have recently been experimenting with a way to sidestep the whole question of how to embed the messages and models of pages into the main message and model entirely: make each page a separate Elmish program.</p>
<p>This is a style that I haven't seen used in Fable or Fabulous, and in fact I have no idea whether it is possible to use it in those frameworks.
In Bolero, while it is still buggy and requires changes to the library itself, I hope to be able to make it available soon.</p>
<p>The idea is that we will have a root Program that will contain the common model (here, the list of books) and dispatch page switches to a nested <code>ProgramComponent</code>.
Each page is a different <code>ProgramComponent</code>, with its own model and message types.</p>
<p>Of course, each page still needs to be able to receive a model from the parent program (the list of books for <code>List</code>, and the book as initial model for <code>Book</code>), and to dispatch messages to the main update.
These two values can be passed to the component as Blazor parameters.
This is the base type that will be implemented by our page components:</p>
<pre><code class="language-fsharp">[&lt;AbstractClass&gt;]
type NestedProgramComponent&lt;'inModel, 'rootMsg, 'model, 'msg&gt;() =
    inherit ProgramComponent&lt;'model, 'msg&gt;()

    let mutable oldInModel = Unchecked.defaultof&lt;'inModel&gt;

    [&lt;Parameter&gt;]
    member val InModel = oldInModel with get, set
    [&lt;Parameter&gt;]
    member val RootDispatch = Unchecked.defaultof&lt;Dispatch&lt;'rootMsg&gt;&gt; with get, set

    override this.OnParametersSet() =
        if not &lt;| obj.ReferenceEquals (oldInModel, this.InModel) then
            oldInModel &lt;- this.InModel
            this.Rerender()
</code></pre>
<p>For example, the <code>Book</code> component is implemented as follows:</p>
<pre><code class="language-fsharp">type BookComponent() as this =
    inherit NestedProgramComponent&lt;BookModel, Msg, BookModel, BookMsg&gt;()
    
    let update message model =
        // Use this.RootDispatch to send messages to the root program
        // ...
        
    let view model dispatch =
        // ...

    override this.Program =
        Program.mkProgram (fun _ -&gt; this.InModel, Cmd.none) update view
</code></pre>
<p>and with a convenience function to instantiate nested program components:</p>
<pre><code class="language-fsharp">module Html =
    open Bolero.Html

    let ncomp&lt;'T, 'inModel, 'rootMsg, 'model, 'msg
                when 'T :&gt; NestedProgramComponent&lt;'inModel, 'rootMsg, 'model, 'msg&gt;&gt;
            (inModel: 'inModel) (rootDispatch: Dispatch&lt;'rootMsg&gt;) =
        comp&lt;'T&gt; [&quot;InModel&quot; =&gt; inModel; &quot;RootDispatch&quot; =&gt; rootDispatch] []
</code></pre>
<p>we can include the appropriate page component inside the main view:</p>
<pre><code class="language-fsharp">let view model dispatch =
    cond model.page &lt;| function
    | List -&gt;
        ncomp&lt;ListComponent,_,_,_,_&gt; model.books dispatch
    | Book isbn -&gt;
        cond (model.books |&gt; List.tryFind (fun book -&gt; book.isbn = isbn)) &lt;| function
        | Some book -&gt;
            ncomp&lt;BookComponent,_,_,_,_&gt; book dispatch
        | None -&gt;
            textf &quot;Unknown book: %s&quot; isbn
</code></pre>
<h1 id="conclusion">Conclusion</h1>
<p>The above approaches each have their advantages and inconvenients. They can even be mixed and matched, depending on how persistent different pages' models needs to be across page switches. Don't be afraid to experiment!</p>
<p><small><em>By Lo&#239;c &quot;Tarmil&quot; Denuzi&#232;re on Tuesday, December 17, 2019</em></small></p>
                  <p class="are-tags"><a href="tag/fsharp" class="tag">fsharp</a> <a href="tag/fsbolero" class="tag">fsbolero</a> <a href="tag/elmish" class="tag">elmish</a> <a class="tag is-info" href="https://twitter.com/intent/tweet?url=https://tarmil.fr/article/2019/12/17/elmish-page-model&amp;text=Managing+page-specific+models+in+Elmish&amp;hashtags=fsharp,fsbolero,elmish">Tweet</a> <a class="tag is-link" href="https://tarmil.fr/article/2019/12/17/elmish-page-model">Permalink</a> </p>
                </article><article class="section">
                  <h1><a href="article/2019/11/24/bolero-webwindow">Desktop applications with Bolero and WebWindow</a></h1>
                  <p>Steve Sanderson <a href="https://blog.stevensanderson.com/2019/11/18/2019-11-18-webwindow-a-cross-platform-webview-for-dotnet-core/">recently published WebWindow</a>: a library that runs a web page in a desktop window, piloted from .NET.
In particular, it can run <a href="https://dotnet.microsoft.com/apps/aspnet/web-apps/blazor">Blazor</a> applications natively on the desktop with minimal changes to their code.
Unlike client-side Blazor, this doesn't involve any WebAssembly: the Blazor code runs in .NET and interacts directly with the web page.</p>
<p><img src="/assets/blazor-macos.jpg" alt="The Blazor sample app running on WebWindows" /></p>
<p>This is pretty cool.
Although it is contained in a web window like an Electron application, it runs with the speed of a native .NET application and comes in a much smaller package.</p>
<p>Obviously, as soon as I saw it, I had to try to use it with <a href="https://fsbolero.io">Bolero</a>, my own F# layer for Blazor.
As it turns out, it runs quite well!
<a href="https://github.com/Tarmil/Bolero.WebWindowTest">Here's a simple working application</a>; let's see how to create it from scratch.</p>
<h2 id="creating-a-bolero-app-on-webwindow-step-by-step">Creating a Bolero app on WebWindow, step by step</h2>
<p>First, if you don't have it yet, install <a href="https://dotnet.microsoft.com/download">the .NET Core 3.0 SDK</a> and the Bolero project template:</p>
<pre><code>dotnet new -i Bolero.Templates
</code></pre>
<p>We can now create a Bolero application.</p>
<pre><code>dotnet new bolero-app --minimal --server=false -o MyBoleroWebWindowApp
cd MyBoleroWebWindowApp
</code></pre>
<p>The full template contains a few pages and uses things like remoting that we would need to untangle for this example, so we'll go for the <code>--minimal</code> template instead.
Also, we don't want to create an ASP.NET Core host application, so we use <code>--server=false</code>.</p>
<p>We now have a solution with a single project, <code>src/MyBoleroWebWindowApp.Client</code>, which will directly be our executable.
Let's fixup the project file <code>MyBoleroWebWindowApp.Client.fsproj</code>.</p>
<ul>
<li><p>First, this is not a web project:</p>
<pre><code class="language-diff"> &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
-&lt;Project Sdk=&quot;Microsoft.NET.Sdk.Web&quot;&gt;
+&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;
</code></pre>
</li>
<li><p>Second, we need to target .NET Core 3.0 and create an executable:</p>
<pre><code class="language-diff">   &lt;PropertyGroup&gt;
-    &lt;TargetFramework&gt;netstandard2.0&lt;/TargetFramework&gt;
+    &lt;TargetFramework&gt;netcoreapp3.0&lt;/TargetFramework&gt;
+    &lt;OutputType&gt;WinExe&lt;/OutputType&gt;
   &lt;/PropertyGroup&gt;
</code></pre>
</li>
<li><p>Now that we removed the <code>Web</code> SDK, the <code>wwwroot</code> will not automatically included in the published application anymore.
But we still need our assets!</p>
<pre><code class="language-diff">   &lt;ItemGroup&gt;
+    &lt;Content Include=&quot;wwwroot\**&quot;&gt;
+      &lt;CopyToOutputDirectory&gt;PreserveNewest&lt;/CopyToOutputDirectory&gt;
+    &lt;/Content&gt;
     &lt;Compile Include=&quot;Main.fs&quot; /&gt;
     &lt;Compile Include=&quot;Startup.fs&quot; /&gt;
   &lt;/ItemGroup&gt;
</code></pre>
</li>
<li><p>Finally, the NuGet references. We need to remove the Blazor build packages that compile our project into a WebAssembly application, and instead add WebWindow.</p>
<pre><code class="language-diff">   &lt;ItemGroup&gt;
     &lt;PackageReference Include=&quot;Bolero&quot; Version=&quot;0.10.1-preview9&quot; /&gt;
-    &lt;PackageReference Include=&quot;Bolero.Build&quot; Version=&quot;0.10.1-preview9&quot; /&gt;
-    &lt;PackageReference Include=&quot;Microsoft.AspNetCore.Blazor.Build&quot; Version=&quot;3.0-preview9.*&quot; /&gt;
-    &lt;PackageReference Include=&quot;Microsoft.AspNetCore.Blazor.DevServer&quot; Version=&quot;3.0-preview9.*&quot; /&gt;
+    &lt;PackageReference Include=&quot;WebWindow.Blazor&quot; Version=&quot;0.1.0-20191120.6&quot; /&gt;
   &lt;/ItemGroup&gt;
 &lt;/Project&gt;
</code></pre>
</li>
</ul>
<p>The main program, <code>Startup.fs</code>, needs a bit of change to start as a WebWindow application rather than a WebAssembly one.
Luckily, Steve made this very easy:</p>
<pre><code class="language-diff"> module Program =
+    open WebWindows.Blazor
 
     [&lt;EntryPoint&gt;]
     let Main args =
-        BlazorWebAssemblyHost.CreateDefaultBuilder()
-            .UseBlazorStartup&lt;Startup&gt;()
-            .Build()
-            .Run()
+        ComponentsDesktop.Run&lt;Startup&gt;(&quot;My Bolero app&quot;, &quot;wwwroot/index.html&quot;)
         0
</code></pre>
<p>And finally, the small JavaScript script that boots Bolero is in a different location, so we need to touch <code>wwwroot/index.html</code>:</p>
<pre><code class="language-diff">-    &lt;script src=&quot;_framework/blazor.webassembly.js&quot;&gt;&lt;/script&gt;
+    &lt;script src=&quot;framework://blazor.desktop.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>And with this, we're all set!
Run the application using your IDE or from the command line:</p>
<pre><code>dotnet run -p src/MyBoleroWebWindowApp.Client
</code></pre>
<blockquote>
<p>Note: if you're using Visual Studio, make sure to remove the file <code>Properties/launchSettings.json</code> it may have created while the SDK was still <code>Web</code>; otherwise, it will try (and fail) to run your project with IIS Express.</p>
</blockquote>
<p><img src="/assets/webwindow-empty.png" alt="The Bolero minimal app running on WebWindow" /></p>
<p>We're on our way!
Although since we created a project using the <code>--minimal</code> template, this is pretty empty.
Quite literally, if you look at <code>Main.fs</code>:</p>
<pre><code class="language-fsharp">let view model dispatch =
    empty
</code></pre>
<p>Because of this empty view, we're only seeing the banner that is present statically in <code>wwwroot/index.html</code>.
Let's make sure that Bolero is indeed running by implementing the &quot;hello world&quot; of the Elmish world, the Counter app, in <code>Main.fs</code>:</p>
<pre><code class="language-fsharp">module MyBoleroWebWindowApp.Client.Main

open Elmish
open Bolero
open Bolero.Html

type Model = { counter: int }

let initModel = { counter = 0 }

type Message =
    | Increment
    | Decrement

let update message model =
    match message with
    | Increment -&gt; { model with counter = model.counter + 1 }
    | Decrement -&gt; { model with counter = model.counter - 1 }

let view model dispatch =
    concat [
        button [on.click (fun _ -&gt; dispatch Decrement)] [text &quot;-&quot;]
        textf &quot; %i &quot; model.counter
        button [on.click (fun _ -&gt; dispatch Increment)] [text &quot;+&quot;]
    ]

type MyApp() =
    inherit ProgramComponent&lt;Model, Message&gt;()

    override this.Program =
        Program.mkSimple (fun _ -&gt; initModel) update view
</code></pre>
<p>And now, if we run again:</p>
<p><img src="/assets/webwindow-counter.png" alt="The Bolero counter app running on WebWindow" /></p>
<p>Hurray!</p>
<h2 id="what-next">What next?</h2>
<p>This is just an experiment to see if Bolero would &quot;just work&quot; with WebWindow and, well, it pretty much does.
As Steve said in his blog article, WebWindow itself is an experiment with no promises of developing it into a proper product.
But it is still pretty cool, and I want to see how far we can combine it with Bolero.
What about remoting with an ASP.NET Core server?
Or HTML template hot reloading?
These will probably need some adjustments to work nicely with WebWindow, and I think I'll experiment some more with these.</p>
<p><small><em>By Lo&#239;c &quot;Tarmil&quot; Denuzi&#232;re on Sunday, November 24, 2019</em></small></p>
                  <p class="are-tags"><a href="tag/fsharp" class="tag">fsharp</a> <a href="tag/fsbolero" class="tag">fsbolero</a> <a class="tag is-info" href="https://twitter.com/intent/tweet?url=https://tarmil.fr/article/2019/11/24/bolero-webwindow&amp;text=Desktop+applications+with+Bolero+and+WebWindow&amp;hashtags=fsharp,fsbolero">Tweet</a> <a class="tag is-link" href="https://tarmil.fr/article/2019/11/24/bolero-webwindow">Permalink</a> </p>
                </article>
<div id="ws152434960"></div>
              <p class="are-tags"></p>
            </div>
            <nav class="level article-prev-next">
              <div class="level-left">
                <div class="level-item">
                  <a href="#"></a>
                </div>
              </div>
              <div class="level-right">
                <div class="level-item">
                  <a href="#"></a>
                </div>
              </div>
            </nav>
          </div>
          <div class="column is-one-third">
            <aside class="menu">
              
              
                <p class="menu-label">September 2022</p>
                <ul class="menu-list"><li><a href="article/2022/9/25/systemtextjson-v1.0">FSharp.SystemTextJson 1.0 released!</a></li></ul>
              
                <p class="menu-label">May 2022</p>
                <ul class="menu-list"><li><a href="article/2022/5/27/fsharp-data-literalproviders-1-0">FSharp.Data.LiteralProviders 1.0 is here!</a></li></ul>
              
                <p class="menu-label">December 2019</p>
                <ul class="menu-list"><li><a href="article/2019/12/17/elmish-page-model">Managing page-specific models in Elmish</a></li></ul>
              
                <p class="menu-label">November 2019</p>
                <ul class="menu-list"><li><a href="article/2019/11/24/bolero-webwindow">Desktop applications with Bolero and WebWindow</a></li></ul>
              
            </aside>
          </div>
        </div>
      </div>
    </section>
    <footer class="footer">
      <div class="content has-text-centered">
        <p>
          &copy; 2019 Loïc Denuzière.
          Website content licensed under <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a>.
          Source code <a href="https://github.com/tarmil/tarmil.github.io">on GitHub</a> and licensed under <a href="https://opensource.org/licenses/mit-license.php">MIT</a>.
        </p>
      </div>
    </footer>
    <script src="Scripts/WebSharper.Core.JavaScript/Runtime.min.js" type="text/javascript" charset="UTF-8"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/highlight.min.js" type="text/javascript" charset="UTF-8"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/languages/fsharp.min.js" type="text/javascript" charset="UTF-8"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/languages/diff.min.js" type="text/javascript" charset="UTF-8"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/languages/xml.min.js" type="text/javascript" charset="UTF-8"></script><!--[if lte IE 7.0]>
<script src="Scripts/WebSharper.Main/Json.min.js" type="text/javascript" charset="UTF-8"></script><![endif]-->
<script src="Scripts/WebSharper.Main/WebSharper.Main.min.js" type="text/javascript" charset="UTF-8"></script><script src="Scripts/WebSharper.Collections/WebSharper.Collections.min.js" type="text/javascript" charset="UTF-8"></script><script src="Scripts/WebSharper.Web/WebSharper.Web.min.js" type="text/javascript" charset="UTF-8"></script><script src="Scripts/blog/blog.min.js" type="text/javascript" charset="UTF-8"></script><script type="text/javascript">
if (typeof IntelliFactory !=='undefined') {
  IntelliFactory.Runtime.ScriptBasePath = 'Scripts/';
  IntelliFactory.Runtime.Start();
}
</script>

  </body>
</html>