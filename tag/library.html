<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Une pipe |&gt; Ceci n&#39;est pas</title>
    <meta id='websharper-data' name='websharper-data' content='{"$TYPES":[["WebSharper","Web","FSharpInlineControl"]],"$DATA":{"$V":{"ws1543074656":{"$T":0,"$V":{"args":[],"funcName":["Blog","Client","Main"]}}}}}' />
<link type="text/css" rel="stylesheet" href="/css/all.css"></link>
<link type="text/css" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/styles/atom-one-light.min.css"></link>

  </head>
  <body>
    <header class="hero is-medium">
      <div class="hero-body">
        <div class="container">
          <a href="/">
            <h1 class="title">Une pipe |&gt; Ceci n&#39;est pas</h1>
            <h2 class="subtitle">Random functional thoughts</h2>
          </a>
        </div>
      </div>
    </header>
    <section class="section">
      <div class="container">
        <div class="columns">
          <div class="column is-two-thirds">
            <div class="content">
              <p>Welcome! I am Loïc Denuzière aka &quot;Tarmil&quot;, and this is my technical blog.
I'm a French developer who's quite passionate about functional programming, and I've been using F# for most of my work for over ten years.</p>
<p>I've been one of the main developers of <a href="https://websharper.com">WebSharper</a>, the F# web framework with both server-side and JavaScript-compiled client-side tools.
Recently I've been focusing more on <a href="https://fsbolero.io">Bolero</a>, a library that runs F# applications in WebAssembly using Blazor, and other personal projects.</p>
<p>Follow me on <a href="https://twitter.com/tarmil_">Twitter</a>, <a href="https://mastodon.tarmil.fr/@tarmil" rel="me">Mastodon</a> and find me on <a href="https://github.com/tarmil">GitHub</a>.</p>
<article class="section">
                  <h1><a href="../article/2023/8/14/systemtextjson-1.2">FSharp.SystemTextJson 1.2 released!</a></h1>
                  <p>I am happy to announce <a href="https://github.com/tarmil/fsharp.systemtextjson">FSharp.SystemTextJson</a> version 1.2!</p>
<p>FSharp.SystemTextJson is a library that provides support for F# types in .NET's standard <a href="https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/how-to?pivots=dotnet-6-0">System.Text.Json</a>.</p>
<p>Here is a summary of the new features in v1.2.</p>
<h2 id="skippable-option-fields-154">Skippable Option fields (<a href="https://github.com/Tarmil/FSharp.SystemTextJson/issues/154">#154</a>)</h2>
<p>Version 1.1 introduced the method <code>JsonFSharpOptions.WithSkippableOptionFields(?bool)</code> that, when set to true, causes <code>None</code> and <code>ValueNone</code> to always be skipped when serialized as the value of a record or union field.
However, even with this option left as false, <code>None</code> and <code>ValueNone</code> were still skipped if the <code>JsonSerializerOptions</code> have <code>DefaultIgnoreCondition</code> set to <code>WhenWritingNull</code>.</p>
<p>In version 1.2, a new overload of <code>JsonFSharpOptions.WithSkippableOptionFields</code> takes an enum as argument that brings more possibilities.</p>
<ul>
<li><p><code>SkippableOptionFields.Always</code> is equivalent to <code>true</code>: record and union fields equal to <code>None</code> and <code>ValueNone</code> are always skipped.</p>
</li>
<li><p><code>SkippableOptionFields.FromJsonSerializerOptions</code> is equivalent to <code>false</code>: record and union fields equal to <code>None</code> and <code>ValueNone</code> are only skipped if <code>JsonSerializerOptions</code> have <code>DefaultIgnoreCondition</code> set to <code>WhenWritingNull</code>.
Otherwise, they are serialized as JSON <code>null</code>.</p>
</li>
<li><p><code>SkippableOptionFields.Never</code> is new: <code>None</code> and <code>ValueNone</code> are never skipped, and always serialized as JSON <code>null</code>.</p>
</li>
</ul>
<h2 id="handling-of-dictionary-and-map-keys-161-and-162">Handling of dictionary and map keys (<a href="https://github.com/Tarmil/FSharp.SystemTextJson/issues/161">#161</a> and <a href="https://github.com/Tarmil/FSharp.SystemTextJson/issues/162">#162</a>)</h2>
<p>In version 1.2, FSharp.SystemTextJson now makes use of System.Text.Json's <code>ReadAsPropertyName</code> and <code>WriteAsPropertyName</code> features.
This manifests in two ways:</p>
<ul>
<li><p>Single-case unions can now be used as keys in a standard <code>Dictionary</code> (and related types).<br />
<strong>NOTE</strong>: This requires System.Text.Json 8.0.</p>
<pre><code class="language-fsharp">let options = JsonFSharpOptions().ToJsonSerializerOptions()

type CountryCode = CountryCode of string

let countries = dict [
    CountryCode &quot;us&quot;, &quot;United States&quot;
    CountryCode &quot;fr&quot;, &quot;France&quot;
    CountryCode &quot;gb&quot;, &quot;United Kingdom&quot;
]

JsonSerializer.Serialize(countries, options)
// --&gt; {&quot;us&quot;:&quot;United States&quot;,&quot;fr&quot;:&quot;France&quot;,&quot;gb&quot;:&quot;United Kingdom&quot;}
</code></pre>
</li>
<li><p>The format for maps can now be customized using <code>JsonFSharpOptions.WithMapFormat(MapFormat)</code>.</p>
<ul>
<li><p><code>MapFormat.Object</code> always serializes maps as objects.
The key type must be supported as key for dictionaries.<br />
<strong>NOTE</strong>: This requires System.Text.Json 8.0.</p>
<pre><code class="language-fsharp">let options = JsonFSharpOptions().WithMapFormat(MapFormat.Object).ToJsonSerializerOptions()

let countries = Map [
    Guid.NewGuid(), &quot;United States&quot;
    Guid.NewGuid(), &quot;France&quot;
    Guid.NewGuid(), &quot;United Kingdom&quot;
]

JsonSerializer.Serialize(countries, options)
// --&gt; {&quot;44e2a549-66c6-4515-970a-a1e85ce42624&quot;:&quot;United States&quot;, ...
</code></pre>
</li>
<li><p><code>MapFormat.ArrayOfPairs</code> always serializes maps as JSON arrays whose items are <code>[key,value]</code> pairs.</p>
<pre><code class="language-fsharp">let options = JsonFSharpOptions().WithMapFormat(MapFormat.ArrayOfPairs).ToJsonSerializerOptions()

let countries = Map [
    &quot;us&quot;, &quot;United States&quot;
    &quot;fr&quot;, &quot;France&quot;
    &quot;uk&quot;, &quot;United Kingdom&quot;
]

JsonSerializer.Serialize(countries, options)
// --&gt; [[&quot;us&quot;,&quot;United States&quot;],[&quot;fr&quot;,&quot;France&quot;],[&quot;uk&quot;,&quot;United Kingdom&quot;]]
</code></pre>
</li>
<li><p><code>MapFormat.ObjectOrArrayOfPairs</code> is the default, and the same behavior as v1.1.
Maps whose keys are string or single-case unions wrapping string are serialized as JSON objects, and other maps are serialized as JSON arrays whose items are <code>[key,value]</code> pairs.</p>
</li>
</ul>
</li>
</ul>
<h2 id="other-improvements">Other improvements</h2>
<ul>
<li><p><a href="https://github.com/Tarmil/FSharp.SystemTextJson/issues/158">#158</a>: Throw an exception when trying to deserialize <code>null</code> into a record or union in any context, rather than only when they are in fields of records and unions.</p>
</li>
<li><p><a href="https://github.com/Tarmil/FSharp.SystemTextJson/issues/163">#163</a>: Add <code>StructuralComparison</code> to the type <code>Skippable&lt;_&gt;</code>. This allows using it with types that are themselves marked with <code>StructuralComparison</code>.</p>
</li>
</ul>
<h2 id="bug-fixes">Bug fixes</h2>
<ul>
<li><p><a href="https://github.com/Tarmil/FSharp.SystemTextJson/issues/160">#160</a>: Fix <code>WithSkippableOptionFields(false)</code> not working for <code>voption</code>.</p>
</li>
<li><p><a href="https://github.com/Tarmil/FSharp.SystemTextJson/issues/164">#164</a>: When deserializing a record with <code>JsonIgnoreCondition.WhenWritingNull</code>, when a non-nullable field is missing, throw a proper <code>JsonException</code> that includes the name of the field, rather than a <code>NullReferenceException</code>.</p>
</li>
</ul>
<p>Happy coding!</p>
<p><small><em>By Lo&#239;c &quot;Tarmil&quot; Denuzi&#232;re on Monday, August 14, 2023</em></small></p>
                  <p class="are-tags"><a href="../tag/fsharp" class="tag">fsharp</a> <a href="../tag/release" class="tag">release</a> <a href="../tag/library" class="tag">library</a> <a href="../tag/fsharp-systemtextjson" class="tag">fsharp-systemtextjson</a> <a class="tag is-info" href="https://twitter.com/intent/tweet?url=https://tarmil.fr/article/2023/8/14/systemtextjson-1.2&amp;text=FSharp.SystemTextJson+1.2+released!&amp;hashtags=fsharp,release,library,fsharp-systemtextjson">Tweet</a> <a class="tag is-link" href="https://tarmil.fr/article/2023/8/14/systemtextjson-1.2">Permalink</a> </p>
                </article><article class="section">
                  <h1><a href="../article/2023/1/21/systemtextjson-v1.1">FSharp.SystemTextJson 1.1 released!</a></h1>
                  <p>I am happy to announce <a href="https://github.com/tarmil/fsharp.systemtextjson">FSharp.SystemTextJson</a> version 1.1!</p>
<p>FSharp.SystemTextJson is a library that provides support for F# types in .NET's standard <a href="https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/how-to?pivots=dotnet-6-0">System.Text.Json</a>.</p>
<p>Here is a summary of the new features in v1.1.</p>
<h2 id="fluent-configuration">Fluent configuration</h2>
<p>The library now comes with a new syntax for configuration.
Instead of a constructor with a mix of optional arguments and enum flags, you can now use a more consistent fluent syntax.</p>
<ul>
<li>The baseline options are declared using one of these static methods on the <code>JsonFSharpOptions</code> type: <code>Default()</code>, <code>NewtonsoftLike()</code>, <code>ThothLike()</code> or <code>FSharpLuLike()</code>.</li>
<li>Then, fluent instance methods set various options and return a new instance of <code>JsonFSharpOptions</code>.</li>
<li>Finally, a converter with the given options can be either added to an existing <code>JsonSerializerOptions</code> with the method <code>AddToJsonSerializerOptions()</code>, or to a new one with <code>ToJsonSerializerOptions()</code>.</li>
</ul>
<p>For example:</p>
<pre><code class="language-fsharp">let options =
    JsonFSharpOptions.Default()
        .WithUnionInternalTag()
        .WithUnionNamedFields()
        .WithUnionTagName(&quot;type&quot;)
        .ToJsonSerializerOptions()

type SomeUnion =
    | SomeUnionCase of x: int * y: string

JsonSerializer.Serialize(SomeUnionCase (1, &quot;test&quot;), options)
// --&gt; {&quot;type&quot;:&quot;SomeUnionCase&quot;,&quot;x&quot;:1,&quot;y&quot;:&quot;test&quot;}
</code></pre>
<p>Note that in the future, newly added options will be available via the fluent configuration, but they may not always be added to the constructor syntax; especially because this can break binary compatibility (see <a href="https://github.com/Tarmil/FSharp.SystemTextJson/issues/132">this issue</a>).</p>
<h2 id="skippable-option-fields">Skippable option fields</h2>
<p>In version 1.0, the default behavior for fields of type <code>option</code> and <code>voption</code> changed: they are no longer serialized as a present or missing field, and instead as a null field.</p>
<p>While the pre-1.0 behavior can be recovered by using the <code>JsonSerializerOptions</code> property <code>DefaultIgnoreCondition</code>, this has other side-effects and multiple users have asked for a cleaner way to use options for missing fields.</p>
<p>This is now possible with the option <code>SkippableOptionFields</code>. This is the first option that is only available via fluent configuration, and not as a <code>JsonFSharpConverter</code> constructor argument.</p>
<pre><code class="language-fsharp">let options =
    JsonFSharpOptions.Default()
        .WithSkippableOptionFields()
        .ToJsonSerializerOptions()

JsonSerializer.Serialize({| x = Some 42; y = None |}, options)
// --&gt; {&quot;x&quot;:42}
</code></pre>
<p>Happy coding!</p>
<p><small><em>By Lo&#239;c &quot;Tarmil&quot; Denuzi&#232;re on Saturday, January 21, 2023</em></small></p>
                  <p class="are-tags"><a href="../tag/fsharp" class="tag">fsharp</a> <a href="../tag/release" class="tag">release</a> <a href="../tag/library" class="tag">library</a> <a href="../tag/fsharp-systemtextjson" class="tag">fsharp-systemtextjson</a> <a class="tag is-info" href="https://twitter.com/intent/tweet?url=https://tarmil.fr/article/2023/1/21/systemtextjson-v1.1&amp;text=FSharp.SystemTextJson+1.1+released!&amp;hashtags=fsharp,release,library,fsharp-systemtextjson">Tweet</a> <a class="tag is-link" href="https://tarmil.fr/article/2023/1/21/systemtextjson-v1.1">Permalink</a> </p>
                </article><article class="section">
                  <h1><a href="../article/2022/9/25/systemtextjson-v1.0">FSharp.SystemTextJson 1.0 released!</a></h1>
                  <p>More than three years after the first release, I am happy to announce <a href="https://github.com/tarmil/fsharp.systemtextjson">FSharp.SystemTextJson</a> version 1.0!</p>
<p>FSharp.SystemTextJson is a library that provides support for F# types in .NET's standard <a href="https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/how-to?pivots=dotnet-6-0">System.Text.Json</a>.</p>
<p>Here is a summary of the new features in v1.0.</p>
<h2 id="jsonname-attribute"><code>JsonName</code> attribute</h2>
<p>System.Text.Json provides an attribute <code>JsonPropertyName</code> to change the name of a property in JSON.
In FSharp.SystemTextJson 1.0, the new attribute <a href="https://github.com/Tarmil/FSharp.SystemTextJson/blob/master/docs/Customizing.md#jsonname"><code>JsonName</code></a> is equivalent but provides more functionality:</p>
<ul>
<li><p>When used on a discriminated union case, <code>JsonName</code> can take a value of type <code>int</code> or <code>bool</code> instead of <code>string</code>.</p>
<pre><code class="language-fsharp">type MyUnion =
    | [&lt;JsonName 1&gt;] One of x: int
    | [&lt;JsonName 2&gt;] Two of y: string

let options = JsonSerializerOptions()
options.Converters.Add(JsonFSharpConverter(JsonUnionEncoding.Default ||| JsonUnionEncoding.InternalTag ||| JsonUnionEncoding.NamedFields))
JsonSerializer.Serialize(Two &quot;two&quot;, options)
// =&gt; {&quot;Case&quot;:2,&quot;x&quot;:&quot;two&quot;}
</code></pre>
</li>
<li><p><code>JsonName</code> can take multiple values.
When deserializing, all these values are treated as equivalent.
When serializing, the first one is used.</p>
<pre><code class="language-fsharp">type Name =
    { [&lt;JsonName(&quot;firstName&quot;, &quot;first&quot;)&gt;]
      First: string
      [&lt;JsonName(&quot;lastName&quot;, &quot;last&quot;)&gt;]
      Last: string }

let options = JsonSerializerOptions()
options.Converters.Add(JsonFSharpConverter())
JsonSerializer.Deserialize&lt;Name&gt;(&quot;&quot;&quot;{&quot;first&quot;:&quot;John&quot;,&quot;last&quot;:&quot;Doe&quot;}&quot;&quot;&quot;, options)
// =&gt; { First = &quot;John&quot;; Last = &quot;Doe&quot; }

JsonSerializer.Serialize({ First = &quot;John&quot;; Last = &quot;Doe&quot; }, options)
// =&gt; {&quot;firstName&quot;:&quot;John&quot;,&quot;lastName&quot;:&quot;Doe&quot;}
</code></pre>
</li>
<li><p><code>JsonName</code> has a settable property <code>Field: string</code>.
It is used to set the JSON name of a union case field with the given name.</p>
<pre><code class="language-fsharp">type Contact =
    | [&lt;JsonName(&quot;email&quot;, Field = &quot;address&quot;)&gt;]
      Email of address: string
    | Phone of number: string

let options = JsonSerializerOptions()
options.Converters.Add(JsonFSharpConverter(JsonUnionEncoding.Default ||| JsonUnionEncoding.InternalTag ||| JsonUnionEncoding.NamedFields))
JsonSerializer.Serialize(Email &quot;john.doe@example.com&quot;)
// =&gt; {&quot;Case&quot;:&quot;Email&quot;,&quot;email&quot;:&quot;john.doe@example.com&quot;}
</code></pre>
</li>
</ul>
<h2 id="record-properties">Record properties</h2>
<p>By default, FSharp.SystemTextJson only serializes the fields of a record.
There are now two ways to also serialize their properties:</p>
<ul>
<li><p>The option <code>includeRecordProperties: bool</code> enables serializing all record properties (except those that have the attribute <code>JsonIgnore</code>, just like fields).</p>
<pre><code class="language-fsharp">type User =
    { id: int
      name: string }

    member this.profileUrl = $&quot;https://example.com/user/{this.id}/{this.name}&quot;

    [&lt;JsonIgnore&gt;]
    member this.notIncluded = &quot;This property is not included&quot;

let options = JsonSerializerOptions()
options.Converters.Add(JsonFSharpConverter(includeRecordProperties = true))
JsonSerializer.Serialize({ id = 1234; name = &quot;john.doe&quot; })
// =&gt; {&quot;id&quot;:1234,&quot;name&quot;:&quot;john.doe&quot;,&quot;profileUrl&quot;:&quot;https://example.com/user/1234/john.doe&quot;}
</code></pre>
</li>
<li><p>The attribute <code>JsonInclude</code> can be used on a specific property to serialize it.</p>
<pre><code class="language-fsharp">type User =
    { id: int
      name: string }

    [&lt;JsonInclude&gt;]
    member this.profileUrl = $&quot;https://example.com/user/{this.id}/{this.name}&quot;

    member this.notIncluded = &quot;This property is not included&quot;

let options = JsonSerializerOptions()
options.Converters.Add(JsonFSharpConverter())
JsonSerializer.Serialize({ id = 1234; name = &quot;john.doe&quot; })
// =&gt; {&quot;id&quot;:1234,&quot;name&quot;:&quot;john.doe&quot;,&quot;profileUrl&quot;:&quot;https://example.com/user/1234/john.doe&quot;}
</code></pre>
</li>
</ul>
<h2 id="breaking-change-missing-fields">BREAKING CHANGE: Missing fields</h2>
<p>In FSharp.SystemTextJson 0.x, using default options, missing fields of type <code>option</code> or <code>voption</code> would be deserialized into <code>None</code> or <code>ValueNone</code>.
This was unintended behavior, which is corrected in version 1.0: these missing fields now throw an error.
To restore the previous behavior, either enable the option <code>IgnoreNullValues = true</code>, or or use the type <a href="https://github.com/Tarmil/FSharp.SystemTextJson/blob/master/docs/Format.md#skippable"><code>Skippable</code></a> instead of <code>option</code> or <code>voption</code>.</p>
<p>Additionally, the option <code>DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull</code> is now treated as a synonym for <code>IgnoreNullValues = true</code>.</p>
<pre><code class="language-fsharp">type Name =
    { firstName: string
      lastName: string option }

let options = JsonSerializerOptions()
options.Converters.Add(JsonFSharpConverter())
JsonSerializer.Deserialize&lt;Name&gt;(&quot;&quot;&quot;{&quot;firstName&quot;:&quot;John&quot;}&quot;&quot;&quot;, options)
// =&gt; JsonException

let options2 = JsonSerializerOptions(IgnoreNullValues = true)
options2.Converters.Add(JsonFSharpConverter())
JsonSerializer.Deserialize&lt;Name&gt;(&quot;&quot;&quot;{&quot;firstName&quot;:&quot;John&quot;}&quot;&quot;&quot;, options2)
// =&gt; { firstName = &quot;John&quot;; lastName = None }

let options3 = JsonSerializerOptions(DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull)
options3.Converters.Add(JsonFSharpConverter())
JsonSerializer.Deserialize&lt;Name&gt;(&quot;&quot;&quot;{&quot;firstName&quot;:&quot;John&quot;}&quot;&quot;&quot;, options3)
// =&gt; { firstName = &quot;John&quot;; lastName = None }

type NameWithSkippable =
    { firstName: string
      lastName: Skippable&lt;string&gt; }

let options4 = JsonSerializerOptions()
options4.Converters.Add(JsonFSharpConverter())
JsonSerializer.Deserialize&lt;Name&gt;(&quot;&quot;&quot;{&quot;firstName&quot;:&quot;John&quot;}&quot;&quot;&quot;, options4)
// =&gt; { firstName = &quot;John&quot;; lastName = Skip }
</code></pre>
<h2 id="built-in-support-in.net-6-and-jsonfsharptypes">Built-in support in .NET 6 and JsonFSharpTypes</h2>
<p>In .NET 6, support has been added in System.Text.Json for a number of F# types.
This support is different from FSharp.SystemTextJson in a number of ways:</p>
<ul>
<li>Records, tuples, lists, sets, maps: <code>null</code> is accepted by the deserializer, and returns a null value.</li>
<li>Records: missing fields are deserialized to default value instead of throwing an error.</li>
<li>Maps: only primitive keys are supported. Numbers and booleans are converted to string and used as JSON objet keys.</li>
<li>Tuples: only supports up to 8 items, and serializes it as a JSON object with keys &quot;Item1&quot;, &quot;Item2&quot;, etc.</li>
<li>Discriminated unions, struct tuples: not supported.</li>
</ul>
<p>FSharp.SystemTextJson takes over the serialization of these types by default; but the option <a href="https://github.com/Tarmil/FSharp.SystemTextJson/blob/master/docs/Customizing.md#types"><code>types: JsonFSharpTypes</code></a> allows customizing which types should be serialized by <code>FSharp.SystemTextJson</code>, and which types should be left to <code>System.Text.Json</code>.</p>
<pre><code class="language-fsharp">let options = JsonSerializerOptions()
// Only use FSharp.SystemTextJson for records and unions:
options.Converters.Add(JsonFSharpOptions(types = (JsonFSharpTypes.Records ||| JsonFSharpTypes.Unions)))

JsonSerializer.Serialize(Map [(1, &quot;one&quot;); (2, &quot;two&quot;)], options)
// =&gt; {&quot;1&quot;:&quot;one&quot;,&quot;2&quot;:&quot;two&quot;}
// whereas FSharp.SystemTextJson would have serialized as:
// =&gt; [[1,&quot;one&quot;],[2,&quot;two&quot;]]
</code></pre>
<p>Happy coding!</p>
<p><small><em>By Lo&#239;c &quot;Tarmil&quot; Denuzi&#232;re on Sunday, September 25, 2022</em></small></p>
                  <p class="are-tags"><a href="../tag/fsharp" class="tag">fsharp</a> <a href="../tag/release" class="tag">release</a> <a href="../tag/library" class="tag">library</a> <a href="../tag/fsharp-systemtextjson" class="tag">fsharp-systemtextjson</a> <a class="tag is-info" href="https://twitter.com/intent/tweet?url=https://tarmil.fr/article/2022/9/25/systemtextjson-v1.0&amp;text=FSharp.SystemTextJson+1.0+released!&amp;hashtags=fsharp,release,library,fsharp-systemtextjson">Tweet</a> <a class="tag is-link" href="https://tarmil.fr/article/2022/9/25/systemtextjson-v1.0">Permalink</a> </p>
                </article><article class="section">
                  <h1><a href="../article/2022/5/27/fsharp-data-literalproviders-1-0">FSharp.Data.LiteralProviders 1.0 is here!</a></h1>
                  <p>I am happy to announce that the library <a href="https://github.com/tarmil/fsharp.data.literalproviders">FSharp.Data.LiteralProviders</a> has reached version 1.0!</p>
<p>FSharp.Data.LiteralProviders is an F# type provider library that provides compile-time constants from various sources, such as environment variables or files:</p>
<pre><code class="language-fsharp">open FSharp.Data.LiteralProviders

// Get a value from an environment variable, another one from a file,
// and pass them to another type provider.

let [&lt;Literal&gt;] ConnectionString = Env&lt;&quot;CONNECTION_STRING&quot;&gt;.Value
let [&lt;Literal&gt;] GetUserDataQuery = TextFile&lt;&quot;GetUserData.sql&quot;&gt;.Text

type GetUserData = FSharp.Data.SqlCommandProvider&lt;GetUserDataQuery, ConnectionString&gt;

let getUserData (userId: System.Guid) =
    GetUserData.Create().Execute(UserId = userId)
</code></pre>
<p>Here is a summary of the new features in v1.0.</p>
<h2 id="running-an-external-command">Running an external command</h2>
<p>The <code>Exec</code> provider runs an external command during compilation and provides its output.</p>
<pre><code class="language-fsharp">open FSharp.Data.LiteralProviders

let [&lt;Literal&gt;] Branch = Exec&lt;&quot;git&quot;, &quot;branch --show-current&quot;&gt;.Output
</code></pre>
<p>More options are available to pass input, get the error output, the exit code, etc.
See <a href="https://github.com/Tarmil/FSharp.Data.LiteralProviders/blob/master/README.md#exec">the documentation</a>.</p>
<h2 id="conditionals">Conditionals</h2>
<p>The sub-namespaces <code>String</code>, <code>Int</code> and <code>Bool</code> provide a collection of compile-time conditional operators for the corresponding types.</p>
<p>For example, you can compare two integer values with <code>Int.LT</code>; combine two booleans with <code>Bool.OR</code>; or choose between two strings with <code>String.IF</code>.</p>
<pre><code class="language-fsharp">open FSharp.Data.LiteralProviders

// Compute the version: get the latest git tag, and add the branch if it's not master or main.

let [&lt;Literal&gt;] TagVersion = Exec&lt;&quot;git&quot;, &quot;describe --tags&quot;&gt;.Output

let [&lt;Literal&gt;] Branch = Exec&lt;&quot;git&quot;, &quot;branch --show-current&quot;&gt;.Output

// Note: the `const` keyword is an F# language quirk, necessary when nesting type providers.
let [&lt;Literal&gt;] IsMainBranch =
    Bool.OR&lt;
        const(String.EQ&lt;Branch, &quot;master&quot;&gt;.Value),
        const(String.EQ&lt;Branch, &quot;main&quot;&gt;.Value)
    &gt;.Value

let [&lt;Literal&gt;] Version =
    String.IF&lt;IsMainBranch,
        Then = TagVersion,
        Else = const(TagVersion + &quot;-&quot; + Branch)
    &gt;.Value
</code></pre>
<p>See <a href="https://github.com/Tarmil/FSharp.Data.LiteralProviders/blob/master/README.md#conditionals">the documentation</a> for all the operators available.</p>
<h2 id="value-as-int-and-as-bool">Value as int and as bool</h2>
<p>The providers try to parse string values as integer and as boolean. If any of these succeed, a value suffixed with <code>AsInt</code> or <code>AsBool</code> is provided.</p>
<pre><code class="language-fsharp">open FSharp.Data.LiteralProviders

let [&lt;Literal&gt;] runNumberAsString = Env&lt;&quot;GITHUB_RUN_NUMBER&quot;&gt;.Value // eg. &quot;42&quot;

let [&lt;Literal&gt;] runNumberAsInt = Env&lt;&quot;GITHUB_RUN_NUMBER&quot;&gt;.ValueAsInt // eg. 42
</code></pre>
<p><small><em>By Lo&#239;c &quot;Tarmil&quot; Denuzi&#232;re on Friday, May 27, 2022</em></small></p>
                  <p class="are-tags"><a href="../tag/fsharp" class="tag">fsharp</a> <a href="../tag/release" class="tag">release</a> <a href="../tag/library" class="tag">library</a> <a href="../tag/literalproviders" class="tag">literalproviders</a> <a class="tag is-info" href="https://twitter.com/intent/tweet?url=https://tarmil.fr/article/2022/5/27/fsharp-data-literalproviders-1-0&amp;text=FSharp.Data.LiteralProviders+1.0+is+here!&amp;hashtags=fsharp,release,library,literalproviders">Tweet</a> <a class="tag is-link" href="https://tarmil.fr/article/2022/5/27/fsharp-data-literalproviders-1-0">Permalink</a> </p>
                </article>
<div id="ws1543074656"></div>
              <p class="are-tags"></p>
            </div>
            <nav class="level article-prev-next">
              <div class="level-left">
                <div class="level-item">
                  <a href="#"></a>
                </div>
              </div>
              <div class="level-right">
                <div class="level-item">
                  <a href="#"></a>
                </div>
              </div>
            </nav>
          </div>
          <div class="column is-one-third">
            <aside class="menu">
              
              
                <p class="menu-label">August 2023</p>
                <ul class="menu-list"><li><a href="../article/2023/8/14/systemtextjson-1.2">FSharp.SystemTextJson 1.2 released!</a></li></ul>
              
                <p class="menu-label">January 2023</p>
                <ul class="menu-list"><li><a href="../article/2023/1/21/systemtextjson-v1.1">FSharp.SystemTextJson 1.1 released!</a></li></ul>
              
                <p class="menu-label">September 2022</p>
                <ul class="menu-list"><li><a href="../article/2022/9/25/systemtextjson-v1.0">FSharp.SystemTextJson 1.0 released!</a></li></ul>
              
                <p class="menu-label">May 2022</p>
                <ul class="menu-list"><li><a href="../article/2022/5/27/fsharp-data-literalproviders-1-0">FSharp.Data.LiteralProviders 1.0 is here!</a></li></ul>
              
            </aside>
          </div>
        </div>
      </div>
    </section>
    <footer class="footer">
      <div class="content has-text-centered">
        <p>
          &copy; 2019 Loïc Denuzière.
          Website content licensed under <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a>.
          Source code <a href="https://github.com/tarmil/tarmil.github.io">on GitHub</a> and licensed under <a href="https://opensource.org/licenses/mit-license.php">MIT</a>.
        </p>
      </div>
    </footer>
    <script src="../Scripts/WebSharper.Core.JavaScript/Runtime.min.js" type="text/javascript" charset="UTF-8"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/highlight.min.js" type="text/javascript" charset="UTF-8"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/languages/fsharp.min.js" type="text/javascript" charset="UTF-8"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/languages/diff.min.js" type="text/javascript" charset="UTF-8"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/languages/xml.min.js" type="text/javascript" charset="UTF-8"></script><!--[if lte IE 7.0]>
<script src="../Scripts/WebSharper.Main/Json.min.js" type="text/javascript" charset="UTF-8"></script><![endif]-->
<script src="../Scripts/WebSharper.Main/WebSharper.Main.min.js" type="text/javascript" charset="UTF-8"></script><script src="../Scripts/WebSharper.Collections/WebSharper.Collections.min.js" type="text/javascript" charset="UTF-8"></script><script src="../Scripts/WebSharper.Web/WebSharper.Web.min.js" type="text/javascript" charset="UTF-8"></script><script src="../Scripts/blog/blog.min.js" type="text/javascript" charset="UTF-8"></script><script type="text/javascript">
if (typeof IntelliFactory !=='undefined') {
  IntelliFactory.Runtime.ScriptBasePath = '../Scripts/';
  IntelliFactory.Runtime.Start();
}
</script>

  </body>
</html>